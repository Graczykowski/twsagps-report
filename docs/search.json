[
  {
    "objectID": "report2.html",
    "href": "report2.html",
    "title": "twsagps package report",
    "section": "",
    "text": "This report comprehends the present state of twsagps package - current issues and further development plans. Package consists of five functions: exposure_PO(), exposure_KDE(), exposure_DR(), exposure_LS() and rast_stats(). The first four functions each utilize one of Time Weighted Spatial Averaging (TWSA) method. Fifth function calculates various statistics for multiple rasters. The TWSA methods are taken from the reference paper (Jankowska et al. 2023) on which the package is based upon - Point Overlay (PO), Kernel Density Estimation (KDE), Density Ranking (DR) with the addition of Line Segment (LS). Report demonstrates code workflow and outcomes.\nFor this demo following packages were used:\n\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\nlibrary(tmaptools)\nlibrary(dplyr)\nlibrary(twsagps)"
  },
  {
    "objectID": "report2.html#introduction",
    "href": "report2.html#introduction",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "1 Introduction",
    "text": "1 Introduction\nThis report comprehends the present state of twsagps package - current issues and further development plans. Package consists of five functions: exposure_PO(), exposure_KDE(), exposure_DR(), exposure_LS() and rast_stats(). The first four functions each utilize one of Time Weighted Spatial Averaging (TWSA) method. Fifth function calculates various statistics for multiple rasters. The TWSA methods are taken from the reference paper (Jankowska et al. 2023) on which the package is based upon - Point Overlay (PO), Kernel Density Estimation (KDE), Density Ranking (DR) with the addition of Line Segment (LS). Report demonstrates code workflow and outcomes.\nFor this demo following packages were used:\n\nlibrary(terra)\nlibrary(exactextractr)\nlibrary(sf)\nlibrary(tmap)\nlibrary(tmaptools)\nlibrary(dplyr)\nlibrary(twsagps)"
  },
  {
    "objectID": "report2.html#research-area-and-sample-data",
    "href": "report2.html#research-area-and-sample-data",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "2 Research area and sample data",
    "text": "2 Research area and sample data\nFor presenting package functioning Geolife GPS Trajectories 1.3 Data (Zheng et al. 2009), (Zheng et al. 2008), (Yu Zheng 2010) was used as sample GPS data. The Geolife dataset consists of significant volumes of time-stamped GPS data retrieved from 182 pariticipants in over five year time span. Research area was limited to San Diego county and GPS data was restricted to the research area. To improve running time of functions Geolife data was reduced to each 10th record. The GPS data was collected between 17th August 2011 and 20th August 2011.\n\ngeol_file = read.csv(\"geolife_san_diego.csv\")\ngeolife_days = geol_file |&gt; select(-X) |&gt; \n  slice(which(row_number() %% 10 == 1))\ngeolife_time = geolife_days |&gt;\n  mutate(dateTime = paste(date, time), \n         dateTime = as.POSIXct(dateTime, format = \"%Y-%m-%d %H:%M:%S\", tz = \"UTC\"))\n\n\n\n\n\n\n\n\n\nlat\nlon\ndate\ntime\ndateTime\n\n\n\n\n33.26486\n-117.4323\n2011-08-17\n21:38:11\n2011-08-17 21:38:11\n\n\n33.26239\n-117.4301\n2011-08-17\n21:38:21\n2011-08-17 21:38:21\n\n\n33.25969\n-117.4280\n2011-08-17\n21:38:31\n2011-08-17 21:38:31\n\n\n33.25700\n-117.4259\n2011-08-17\n21:38:41\n2011-08-17 21:38:41\n\n\n33.25437\n-117.4238\n2011-08-17\n21:38:51\n2011-08-17 21:38:51\n\n\n33.25162\n-117.4216\n2011-08-17\n21:39:01\n2011-08-17 21:39:01\n\n\n\n\n\n\nTable 1: Geolife records with dateTime\n\n\n\n\nNDVI raster data was applied as sample environmental layer. Indicator was calculated from a Landsat 8 image involving San Diego county which was captured on 22nd Februrary 2024.\n\nlandsat_red = rast(\"landsat_ndvi/LC09_L2SP_040037_20240222_20240224_02_T1_SR_B4.TIF\")\nlandsat_nir = rast(\"landsat_ndvi/LC09_L2SP_040037_20240222_20240224_02_T1_SR_B5.TIF\")\nlandsat_ndvi = (landsat_nir - landsat_red) / (landsat_nir + landsat_red)\n\n\n\n\n\n\n\n\n\nFigure 1: NDVI data (credits - U.S. Geological Survey) with Geolife San Diego data\n\n\n\n\n\nVector environmental layer of bike routes lines was utilized as consecutive sample data. Cycling paths span over San Diego county and were sourced from City of San Diego Open Data portal updated at 2024-04-30. Bicycle trail data is reclassified to numeric type based on class attribute indicating category of bike lane.\n\nClass I - Paved right-of-way for exclusive use by bicyclists, pedestrians and those using non-motorized modes of travel. They are physically separated from vehicular traffic and can be constructed in roadway right-of-way or exclusive right-of-way (Reclassified as 3)\nClass II - One-way facilities on either side of a roadway with pavement striping and signage used to allocate a portion of a roadway for exclusive or preferential bicycle travel (Reclassified as 2)\nClass III - Shared use with motor vehicle traffic within the same travel lane. Designated by signs (Reclassified as 1)\nClass IV (One-Way)/Class IV (Two-Way) - Exclusive bike facility physically separated from motor traffic and distinct from the sidewalk (Reclassified as 4)\n\n\nsd_bike = vect(\"san_diego_bike/bike_routes_datasd.shp\")\nsd_bike$class = replace(sd_bike$class, sd_bike$class == \"Class IV (Two-Way)\", \"Class IV (One-Way)\")\nsd_bike$class = factor(sd_bike$class, levels = c(\"Class III\", \"Class II\", \"Class I\", \"Class IV (One-Way)\")) |&gt; as.numeric()\n\n\n\n\n\n\n\n\n\nFigure 2: San Diego bike routes lines data with reclassified “class” attribute (credits - City of San Diego)\n\n\n\n\nAll sample data is avaible at repository."
  },
  {
    "objectID": "report2.html#methods",
    "href": "report2.html#methods",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "3 Methods",
    "text": "3 Methods\n\n3.1 Point Overlay (PO)\nPoint Overlay method is implemented in exposure_PO() function. Evaluated by converting GPS point SpatVector data to SpatRaster data type using sum function.\n\n\n3.2 Kernel Density Estimation (KDE)\nThe exposure_KDE() utilizes the KDE method. Method generates smoothed buffers aroud GPS data considering differences in spatial distribution and influence. Function calculates exposure from GPS points coordinates on matrix of coordinates using spat_kde() created for this package. The spat_kde() function, used in computing KDE, utilizes quartic kernel (Silverman 1986):\n\n\\hat{f}(x) = \\frac{1}{h^2} \\sum^n_{i=1} K \\{\\frac{1}{h}(x - X_i)\\}\n\nand\n\nK_2(x) = \\left\\{ \\begin{array}{rcl} 3\\pi^{-1}(1-x^Tx)^2 & if & x^Tx &gt; 1 \\\\ 0 & \\ & otherwise \\end{array}\\right.\n\nwhere h is kernel search radius (bandwidth), x current cell coordinates and X_i current data point. KDE formula does not incorporate further division by n number of cells for the purpose of calculating KDE in intensity unit (https://gis.stackexchange.com/a/389744).\n\n\n3.3 Density Ranking (DR)\nDensity Ranking method in exposure_DR() is based on DR() function from yenchic/density_ranking GitHub repository [Chen and Dobra (2020)](Chen 2019) by implementing Empirical Cumulative Distrubution Function in spat_dr() function created fot this package. DR serves as a improvement to KDE method by ranking KDE values (Jankowska et al. 2023). Function implements DR formula (Chen and Dobra 2020):\n\n\\hat{\\alpha}(x) = \\sum^n_{i=1}I(\\hat{p}(X_i)\\leq\\hat{p}(x))\n\nThe \\hat{\\alpha}(x) takes value between 0 and 1. Lack of n number of cells division in formula mentioned in Section 3.2.\n\n\n3.4 Line Segment (LS)\nNew addition in TWSA approaches is a Line Segment method applied in exposure_LS() drawn from michaeldgarber/microclim-static-v-dynam GitHub repository. Code applied in exposure_LS() consists of modified functions from the repository’s demo. Line Segment puts emphasis on time component of GPS data. Firstly, trajectories following GPS movement. Than buffers around each trajectory segment are created and combined with time elapsed between every two GPS records. Secondly, weighted values for each segment are extracted from environmental layer. Obtained polygons are converted to raster with sum function afterwards.\nDemo applies terra::extract() in deriving environmental data values which is substituted in exposure_LS() with exactextractr::exact_extract() function due to significant computation speed difference."
  },
  {
    "objectID": "report2.html#processing",
    "href": "report2.html#processing",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "4 Processing",
    "text": "4 Processing\n\n4.1 Parameters\nTWSA functions of twsagps package utilizes various arguments:\n\ndata - data.frame, SpatVector points or sf data.frame containing only POINTS of GPS data\nx - x or longitude coordinates column name if data is a data.frame\ny - y or latitude coordinates column name if data is a data.frame\nNA_val - value in x and y marked as NA if data is a data.frame\ntime_data (LS) - column of data containing POSIXct class objects\ntime_unit (LS) - unit of time weights in time_data\ncellsize - size of raster cells in meters if output has a longtitude/latitude CRS or in the units of output CRS\ngroup_split - column of data based on which it is grouped and split. For n groups output will be n SpatRasters\nbandwidth (KDE/DR/LS) - bandwidth in units of output CRS (DR/KDE) or size of buffer in meters if output has a longtitude/latitude CRS or in the units of output CRS (LS)\nenv_data - stars, SpatRaster, SpatVector or sf object class of environmental data. Activity space is calculated when not set\nenv_field - column name of SpatVector/sf env_data that env_data will be rasterized on\nenv_buff - optional buffer around SpatVector/sf env_data in meters if output has a longtitude/latitude CRS or in the units of the CRS\nnormalize - if TRUE activity space SpatRaster is normalized\nnorm_method - normalization method - “center”, “scale”, “standardize” or “range”. Default is “range”\nnorm_group - if FALSE each activity space SpatRaster is normalized seperately. If TRUE activity space SpatRasters are normalized to SpatRaster with highest max value. Not ignored when normalize is TRUE, norm_method is “range” and group_split is set\ntime_only_norm (LS) - TEMPORARY - type of time normalization. If TRUE only time_data is normalized. If FALSE and norm_method is “range” normalization is conducted with regard to spatial distribution\ngrid_extent - if stars or SpatRaster grid_extent is output’s grid. If SpatExtent, sf bbox object or numeric vector c(xmin, xmax, ymin, ymax) grid_extent is output’s extent\ninput_crs- CRS of data’s coordinates if data is a data.frame\noutput_crs- CRS of output\nfilepath - output filename\n\n\ndata = geolife_time\nx = \"lon\"\ny = \"lat\"\nNA_val = NULL\ntime_data = \"dateTime\"\ntime_unit = \"mins\"\ncellsize = 50\ngroup_split = \"date\"\nbandwidth = 200\n\n# ndvi env_data\nenv_data = landsat_ndvi\nenv_field = NULL\nenv_buff = NULL\n\n# bike env_data\nenv_data = sd_bike\nenv_field = \"class\"\nenv_buff = 50\n\nnormalize = TRUE\nnorm_method = \"range\"\nnorm_group = TRUE\ntime_only_norm = FALSE\ngrid_extent = NULL\ninput_crs = \"EPSG:4326\"\noutput_crs = crs(landsat_ndvi)\nfilepath = NULL\n\n\n\n4.2 Entry error handling\nWith the aim of enhancing versatility of TWSA functions multiple types of objects are managed as arguments. Unhandled and handled classes are filtered and processed to uniform type returning proper messages, warnings and errors.\nInput of environmental data must be stars, SpatRaster, SpatVector or sf object class. Stars is converted into SpatRaster and sf into SpatVector.\n\n# handle stars objects rasters as env_data\nif (!is.null(env_data)) {\n  if (any(class(env_data) == \"stars\")){\n    env_data = terra::rast(env_data)\n  } else if (any(class(env_data) == \"sf\")) {\n    env_data = terra::vect(env_data)\n  } else if (any(!class(env_data) %in% c(\"SpatVector\", \"SpatRaster\"))){\n    stop(\"Invalid env_data - env_data neither stars, sf, SpatVector nor SpatRaster class\")\n  }\n}\n\nGrid extent argument handles stars, SpatRaster, SpatExtent, sf bbox class objects and numeric vector of 4 values indicating boundaries of extent (xmin, xmax, ymin, ymax). For grid extent stars class the object is transformed to SpatRaster and sf bbox or vector to SpatExtent.\n\n# handle grid_extent\nif (!is.null(grid_extent)){\n  if (any(class(grid_extent) == \"stars\")){\n    grid_extent = terra::rast(grid_extent)\n  } else if (any(class(grid_extent) == \"bbox\" || (is.vector(grid_extent) &&\n                                                  all(class(grid_extent) == \"numeric\") && length(grid_extent) == 4))){\n    grid_extent = terra::ext(grid_extent)\n  } else if (any(!class(grid_extent) %in% c(\"SpatExtent\", \"SpatRaster\"))){\n    stop(\"Invalid grid_extent - grid_extent neither stars, SpatRaster, SpatExtent, bbox class nor numeric vector of 4 length\")\n  }\n}\n\nNormalize and groups normalization arguments are boolean. They undergo tests to ascertain interpretability as logical, subsequently converted to logical.\n\n# handle normalize and norm_group\nif (is.na(as.logical(normalize))){\n  stop(\"Invalid normalize argument - normalize argument cannot be interpreted as boolean\")\n} else {\n  normalize = as.logical(normalize)\n}\n\nif (is.na(as.logical(norm_group))){\n  stop(\"Invalid norm_group argument - norm_group argument cannot be interpreted as boolean\")\n} else {\n  norm_group = as.logical(norm_group)\n}\n\nNormalization method is required to be one of normalization methods from BBmisc::normalize(). When normalization is conducted and method is not center, scale, standardize or range, argument is assigned to default method - range.\n\n# handle norm_method\nif (!norm_method %in% c(\"center\", \"scale\", \"standardize\", \"range\") && normalize == TRUE) {\n  warning('Invalid norm_method - applying default normalization method \"range\"')\n  norm_method = \"range\"\n}\n\n\n4.2.1 Kernel Density Estimation/Density Ranking/Line Segment\nIn exposure_KDE(), exposure_DR() and exposure_LS() obligatory bandwidth argument is implemented. Bandwidth is constrained to be single positive numeric value.\n\n#handle bandwidth\nif (is.null(bandwidth)){\n  stop(\"Missing bandwidth argument. Provide valid bandwidth\")\n} else if (length(bandwidth) != 1 || !is.numeric(bandwidth) || bandwidth &lt;= 0){\n  stop(\"Invalid bandwidth argument - bandwidth is neither positive nor single numeric value\")\n}\n\n\n\n4.2.2 Line Segment\nLine Segment temporary time only norm argument (see Section 6.2) is expected to be logical and is handled analogously to normalize and groups normalization arguments.\n\n# handle time_only_norm\nif (is.na(as.logical(time_only_norm))){\n  stop(\"Invalid time_only_norm argument - time_only_norm argument cannot be interpreted as boolean\")\n} else {\n  time_only_norm = as.logical(time_only_norm)\n}\n\n\n\n\n4.3 Entry processing\nConsidering numerous GPS data types, grid extent, environmental layer and CRS arguments GPS data is required to be preprocessed prior to further computation. Initially data frame GPS dataset class is handled. Obligatory for developing spatial data x and y coordinates columns are validated. Afterwards star_processing() function is called.\n\n# get spatial data with correct crs\nif (!is.null(data)){\n  if (all(class(data) == \"data.frame\")){\n    if (all(!c(is.null(x), is.null(y)))){\n      x_enq = rlang::enquo(x)\n      y_enq = rlang::enquo(y)\n\n      if (all(c(rlang::quo_name(y_enq), rlang::quo_name(y_enq)) %in% colnames(data))){\n\n        data_proj = start_processing(data = data, x = rlang::quo_name(x_enq),\n                                     y = rlang::quo_name(y_enq), NA_val = NA_val,\n                                     env_data = env_data, grid_extent = grid_extent,\n                                     input_crs = input_crs, output_crs = output_crs)\n      } else {\n        stop(\"Invalid x or y arguments - x or y are not a column in data\")\n      }\n    } else {\n      stop('Missing x or y arguments for data \"data.frame\" class')\n    }\n  } else {\n    data_proj = start_processing(data = data, env_data = env_data,\n                                 grid_extent = grid_extent, input_crs = input_crs,\n                                 output_crs = output_crs)\n  }\n} else {\n  stop(\"Missing data argument - provide valid data argument\")\n}\n\n\n4.3.1 Start_processing function\nThe start_processing() evaluates target SpatVector points GPS data class incorporating exclusion of NA values and CRS transformations with properly signalled conditions.\n\n\n\nListing 1: start_processing function\n\n\n\n\nCode\nstart_processing = function(data, x, y, NA_val, env_data, grid_extent,\n                            input_crs, output_crs){\n\n  # get spatial data\n  if (all(class(data) == \"data.frame\")) {\n    if (is.null(input_crs)){ # implement so missing works\n      input_crs = \"\"\n    }\n    if (!is.null(NA_val)) {\n      if (is.numeric(NA_val)){\n        n_row = nrow(data)\n        data = data[data[x] != NA_val & data[y] != NA_val,]\n        message(paste0(\"Removing rows containing default NA value \",\n                       NA_val, \" in x and y columns - removing \", n_row - nrow(data), \" rows\"))\n      } else {\n        warning(\"Invalid NA_val argument - NA_val is not numeric. Ignoring NA_val argument\")\n      }\n\n    }\n    if (any(is.na(data[,c(x,y)]))){\n      n_row_NA = nrow(data)\n      data = tidyr::drop_na(data, x, y)\n      message(paste0(\"Removing rows containing NA in x and y columns - removing\", n_row_NA - nrow(data), \" rows\"))\n\n    }\n    data_points = terra::vect(x = data, geom = c(x, y), crs = input_crs)\n\n  } else if (any(class(data) == \"sf\") && all(sf::st_geometry_type(data) == \"POINT\")){\n    data_points = terra::vect(data)\n\n    if (!is.null(input_crs)){\n      message(\"Ignoring input_crs argument\")\n    }\n\n} else if (any(class(data) == \"SpatVector\") && terra::geomtype(data) == \"points\") {\n    data_points = data\n    if (!is.null(input_crs)){\n      message(\"Ignoring input_crs argument\")\n    }\n  } else {\n    stop(\"Object data is neither data.frame, sf nor SpatVector class\")\n  }\n\n  data_crs = terra::crs(data_points)\n\n  # crs\n  if (!is.null(output_crs)){\n    if (data_crs == \"\") {\n      message(\"Setting data crs to output_crs\")\n      terra::crs(data_points) = output_crs\n      data_proj = data_points\n    } else {\n      message(\"Projecting data to output_crs\")\n      data_proj = terra::project(data_points, output_crs)\n    }\n  } else if (!is.null(grid_extent) && class(grid_extent) == \"SpatRaster\") {\n    if (data_crs == \"\") {\n      message(\"Setting data crs to grid_extent crs\")\n      terra::crs(data_points) = terra::crs(grid_extent)\n      data_proj = data_points\n    } else {\n      message(\"Projecting data to grid_extent crs\")\n      data_proj = terra::project(data_points, grid_extent)\n    }\n  } else if (data_crs != \"\") { # any invalid/empty crs\n    data_proj = data_points\n  } else if (!is.null(env_data)) {\n    message(\"Setting data crs to environmental data crs\")\n    terra::crs(data_points) = terra::crs(env_data)\n    data_proj = data_points\n  } else {\n    message(\"No crs specified\")\n    data_proj = data_points\n  }\n  # crop to grid_extent\n  if (!is.null(grid_extent)){\n    if (class(grid_extent) == \"SpatExtent\"){\n      data_proj = terra::crop(data_proj, grid_extent)\n    } else {\n      if (terra::crs(data_proj) != terra::crs(grid_extent)){\n        grid_rast = terra::project(grid_rast, terra::crs(data_proj))\n      }\n      data_proj = terra::crop(data_proj, terra::ext(grid_extent))\n    }\n  }\n  \n  return(data_proj)\n}\n\n\n\n\n\nAt the outset function handles various GPS dataset classes. For data frame class object input CRS is tested. Thereafter, rows containing value from NA_val argument or NA value in x and y columns are omitted. Utilizing processed coordinates columns SpatVector object with input CRS is generated. In cases of sf data frame containing only POINTS GPS data is converted to SpatVector. Points SpatVector and sf class ignore input CRS.\n\n# get spatial data\nif (all(class(data) == \"data.frame\")) {\n  if (is.null(input_crs)){\n    input_crs = \"\" # create vector with empty crs\n  }\n  if (!is.null(NA_val)) {\n    if (is.numeric(NA_val)){\n      n_row = nrow(data)\n      data = data[data[x] != NA_val & data[y] != NA_val,]\n      message(paste0(\"Removing rows containing default NA value \",\n                     NA_val, \" in x and y columns - removing \", n_row - nrow(data), \" rows\"))\n    } else {\n      warning(\"Invalid NA_val argument - NA_val is not numeric. Ignoring NA_val argument\")\n    }\n\n  }\n  if (any(is.na(data[,c(x,y)]))){\n    n_row_NA = nrow(data)\n    data = tidyr::drop_na(data, x, y)\n    message(paste0(\"Removing rows containing NA in x and y columns - removing\", n_row_NA - nrow(data), \" rows\"))\n  }\n  data_points = terra::vect(x = data, geom = c(x, y), crs = input_crs)\n} else if (any(class(data) == \"sf\") && all(sf::st_geometry_type(data) == \"POINT\")){\n  data_points = terra::vect(data)\n\n  if (!is.null(input_crs)){\n    message(\"Ignoring input_crs argument\")\n  }\n\n} else if (any(class(data) == \"SpatVector\") && terra::geomtype(data) == \"points\") {\n  data_points = data\n  if (!is.null(input_crs)){\n    message(\"Ignoring input_crs argument\")\n  }\n} else {\n  stop(\"Object data is neither data.frame, sf nor SpatVector class\")\n}\n\nSubsequently, start_process() function manages setting and transformation of GPS CRS. Operation has regard to following hierarchy - output CRS, SpatRaster grid extent, not empty currect SpatVector CRS and environmental dataset. Whilst none of conditions mentioned beforehand are fulfilled, the SpatVector’s CRS remains empty.\n\ndata_crs = terra::crs(data_points)\n\n# crs\nif (!is.null(output_crs)){\n  if (data_crs == \"\") {\n    message(\"Setting data crs to output_crs\")\n    terra::crs(data_points) = output_crs\n    data_proj = data_points\n  } else {\n    message(\"Projecting data to output_crs\")\n    data_proj = terra::project(data_points, output_crs)\n  }\n} else if (!is.null(grid_extent) && class(grid_extent) == \"SpatRaster\") {\n  if (data_crs == \"\") {\n    message(\"Setting data crs to grid_extent crs\")\n    terra::crs(data_points) = terra::crs(grid_extent)\n    data_proj = data_points\n  } else {\n    message(\"Projecting data to grid_extent crs\")\n    data_proj = terra::project(data_points, grid_extent)\n  }\n} else if (data_crs != \"\") { # any invalid/empty crs\n  data_proj = data_points\n} else if (!is.null(env_data)) {\n  message(\"Setting data crs to environmental data crs\")\n  terra::crs(data_points) = terra::crs(env_data)\n  data_proj = data_points\n} else {\n  message(\"No crs specified\")\n  data_proj = data_points\n}\n\nProjecting data to output_crs\n\n\nFinally, SpatVector is cropped to grid extent and returns processed GPS points SpatVector.\n\n# crop to grid_extent\nif (!is.null(grid_extent)){\n  if (class(grid_extent) == \"SpatExtent\"){\n    data_proj = terra::crop(data_proj, grid_extent)\n  } else {\n    if (terra::crs(data_proj) != terra::crs(grid_extent)){\n      grid_rast = terra::project(grid_rast, terra::crs(data_proj))\n    }\n    data_proj = terra::crop(data_proj, terra::ext(grid_extent))\n  }\n}\n\n\n\n4.3.2 Line Segment\nAfter processing CRS and SpatVector data in start_processing() Line Segment performs additional validation for time data and omits records with NA value.\n\n# if time_data remove points with NA time_data\nif (!is.na(time_data)){\n  enq_time = rlang::enquo(time_data)\n  time_cname = rlang::quo_name(enq_time)\n  if (!time_cname %in% terra::names(data_proj)){\n    stop(\"Invalid time_data argument - time_data is not a column name in data\")\n  } else if (any(is.na(data_proj[time_cname]))){\n    n_row = nrow(data_proj)\n    data_proj = tidyterra::drop_na(data_proj,  time_cname)\n    message(paste0(\"Removing points with NA \", time_cname, \" values - removing \", n_row - nrow(data_proj), \" rows\"))\n  }\n}\n\n\n\n\n4.4 Grid Raster\nUpon managing CRS and numerous class objects computing of grid raster is conducted, later utilized in output raster calculation. The grid_calc() function incorporates cellsize, bandwidth, grid extent and environmental raster layer arguments in evaluation of grid raster. In scenarios where the grid extent is a SpatRaster, it is regarded as grid raster, with the calculation of the latter omitted.\n\nif (!is.null(grid_extent) && any(class(grid_extent) == \"SpatRaster\")){\n  if (terra::crs(data_proj) != terra::crs(grid_extent)){\n    grid_extent = terra::project(grid_extent, terra::crs(data_proj))\n  }\n  grid_rast = grid_extent\n} else {\n  grid_rast = calc_grid(x = data_proj, cellsize = cellsize, env_data = env_data,\n                        grid_extent = grid_extent, bandwidth = bandwidth, is_LS = TRUE)\n}\n\n\n4.4.1 Calc_grid function\n\n\n\nListing 2: grid_calc function\n\n\n\n\nCode\ncalc_grid = function(x, bandwidth, cellsize, env_data, grid_extent, is_LS = FALSE){\n\n  if (!is.null(grid_extent)){ # grid_extent as ext of grid rast\n\n    extent = grid_extent\n  } else { # calculate extent\n    extent = terra::ext(x)\n    if (!is.null(bandwidth)) { # for KDE/DR expand extent by bandwidth\n      if(is_LS == FALSE){\n        extent = c(terra::xmin(extent) - bandwidth, terra::xmax(extent) + bandwidth,\n                   terra::ymin(extent) - bandwidth, terra::ymax(extent) + bandwidth)\n      } else { # for LS in lon/lat crs bandwidth is still in meters (terra::buffer)\n        temp_buff = terra::buffer(x, bandwidth)\n        extent = terra::ext(temp_buff)\n      }\n    }\n  }\n\n  if(!is.null(cellsize) && length(cellsize) == 1 && is.numeric(cellsize) && cellsize &gt; 0) { # cellsize included\n\n    if (suppressWarnings(!is.na(terra::is.lonlat(x)) && terra::is.lonlat(x))){\n      # crs units in degrees\n      # is.na if empty crs to skip error\n      warning(\"Cellsize is not stable - cells are not rectangular\")\n\n      if (!is.null(bandwidth) && bandwidth &gt; 0.1 && is_LS == FALSE) {\n        message(paste0(\"CRS is in lontitude/latitude and bandwidth is \", bandwidth,\n      \" - bandwidth is calculated in CRS units. Is bandwidth in correct unit?\"))\n      }\n\n      dist_lon = geosphere::distm(c(extent[1], extent[3]), c(extent[2], extent[3]),\n                                  fun = geosphere::distHaversine)\n      dist_lat = geosphere::distm(c(extent[1], extent[3]), c(extent[1], extent[4]),\n                                  fun = geosphere::distHaversine)\n\n      # number of cells\n      x_cells = (dist_lon / cellsize) |&gt; as.integer()\n      y_cells = (dist_lat / cellsize) |&gt; as.integer()\n\n      # empty_rast for units in degrees\n      grid_rast = terra::rast(crs = terra::crs(x), nrows=y_cells,\n                              ncols=x_cells, extent = extent)\n\n    } else {\n      grid_rast = terra::rast(crs = terra::crs(x), extent = extent,\n                              resolution = cellsize)\n    }\n\n  } else if  (!is.null(env_data) && any(class(env_data) == \"SpatRaster\")){ #if incorrect cellsize and env_data exists\n    warning(\"Cellsize invalid or not set - using cellsize from env_data\")\n\n    if (terra::linearUnits(env_data) == terra::linearUnits(x)){\n      # project env data with the same cellsize\n      env_data_proj = terra::project(env_data, terra::crs(x), res = terra::res(env_data)[1])\n      # if env_data in lat/lon only quadratic cells\n\n    } else {\n      env_data_proj = terra::project(env_data, terra::crs(x))\n    }\n    if (is.null(grid_extent)){\n      # extent modified to preserve cellsize\n      grid_rast = terra::crop(env_data_proj, extent)\n    } else {\n      # if grid_extent specified and missing cellsize grid_extent is prior to\n      # cellsize and cellsize is slightly modified\n      grid_rast = env_data_proj\n      terra::ext(grid_rast) = extent\n    }\n  } else {\n    stop(\"Invalid or is.null cellsize - provide valid cellsize or env_data\")\n  }\n  return(grid_rast)\n}\n\n\n\n\n\nAt first grid_calc() function evaluates extent of grid rast. For grid extent as SpatExtent, sf bbox object or vector it acts as extent for grid rast. Otherwise, extent is derived from GPS SpatVector data. DR, KDE and LS methods extents are additionally extended for the purpose of preventing cropping cells with values. Kernel Density Estimation and Density Ranking extensions apply bandwidth value. Line Segment, utilizing terra::buffer(), buffers in longitude/latitude CRS are calculated in meters. Therefore, extension by bandwidth in longitude/latitude CRS unit is not viable. Subsequently, the extent is based on boundary box of buffered GPS SpatVector layer.\n\nif (!is.null(grid_extent)){ # grid_extent as ext of grid rast\n\n  extent = grid_extent\n} else { # calculate extent\n  extent = terra::ext(data_proj)\n  if (!is.null(bandwidth)) { # for KDE/DR expand extent by bandwidth\n    if(is_LS == FALSE){\n      extent = c(terra::xmin(extent) - bandwidth, terra::xmax(extent) + bandwidth,\n                 terra::ymin(extent) - bandwidth, terra::ymax(extent) + bandwidth)\n    } else { # for LS in lon/lat crs bandwidth is still in meters (terra::buffer)\n      temp_buff = terra::buffer(data_proj, bandwidth)\n      extent = terra::ext(temp_buff)\n    }\n  }\n}\n\nAfterwards, computation of grid raster using cellsize, extent and SpatVector CRS is performed. Number of cells for longitude/latitude CRS is calculated individually implementing spherical distance to evaluate non-rectangular cells. Additionally, KDE and DR execute further bandwidth size and unit verification with the aim of feasible prevention of excessive memory usage in method specific calculations (Section 4.8). For missing or incorrect cellsize argument environmental SpatRaster is applied. In scenarios where grid extent is set, extent is preserved at the expense of environmental cellsize. Otherwise, extent is modified to maintain cellsize.\n\nif(!is.null(cellsize) && length(cellsize) == 1 && is.numeric(cellsize) && cellsize &gt; 0) { # cellsize included\n\n  if (suppressWarnings(!is.na(terra::is.lonlat(data_proj)) && terra::is.lonlat(data_proj))){\n    # crs units in degrees\n    # is.na if empty crs to skip error\n    warning(\"Cellsize is not stable - cells are not rectangular\")\n\n    if (!is.null(bandwidth) && bandwidth &gt; 0.1 && is_LS == FALSE) {\n      message(paste0(\"CRS is in lontitude/latitude and bandwidth is \", bandwidth,\n    \" - bandwidth is calculated in CRS units. Is bandwidth in correct unit?\"))\n    }\n\n    dist_lon = geosphere::distm(c(extent[1], extent[3]), c(extent[2], extent[3]),\n                                fun = geosphere::distHaversine)\n    dist_lat = geosphere::distm(c(extent[1], extent[3]), c(extent[1], extent[4]),\n                                fun = geosphere::distHaversine)\n\n    # number of cells\n    x_cells = (dist_lon / cellsize) |&gt; as.integer()\n    y_cells = (dist_lat / cellsize) |&gt; as.integer()\n\n    # empty_rast for units in degrees\n    grid_rast = terra::rast(crs = terra::crs(data_proj), nrows=y_cells,\n                            ncols=x_cells, extent = extent)\n\n  } else {\n    grid_rast = terra::rast(crs = terra::crs(data_proj), extent = extent,\n                            resolution = cellsize)\n  }\n\n} else if  (!is.null(env_data) && any(class(env_data) == \"SpatRaster\")){ #if incorrect cellsize and env_data exists\n  warning(\"Cellsize invalid or not set - using cellsize from env_data\")\n\n  if (terra::linearUnits(env_data) == terra::linearUnits(data_proj)){\n    # project env data with the same cellsize\n    env_data_proj = terra::project(env_data, terra::crs(data_proj), res = terra::res(env_data)[1])\n    # if env_data in lat/lon only quadratic cells\n\n  } else {\n    env_data_proj = terra::project(env_data, terra::crs(data_proj))\n  }\n  if (is.null(grid_extent)){\n    # extent modified to preserve cellsize\n    grid_rast = terra::crop(env_data_proj, extent)\n  } else {\n    # if grid_extent specified and missing cellsize grid_extent is prior to\n    # cellsize and cellsize is slightly modified\n    grid_rast = env_data_proj\n    terra::ext(grid_rast) = extent\n  }\n} else {\n  stop(\"Invalid or missing cellsize - provide valid cellsize or env_data\")\n}\n\n\n\n\n4.5 Convert SpatVector environmental data\nWith grid raster computed environmental SpatVector layer is rasterized in env_vect() function utilizing environmental buffer and environmental field arguments. Conversion to SpatRaster is performed on bike routes lines San Diego dataset.\n\n# if env_data is vector data - create optional buffer and rasterize to grid raster\nif (!is.null(env_data) && any(class(env_data) == \"SpatVector\")) {\n\n  env_data = env_vect(env = env_data, env_buff = env_buff,\n                      env_field = env_field, grid = grid_rast)\n}\n\n\n4.5.1 Env_vect function\nEnvironmental buffer argument acts as tool to adapt SpatVector environmental datasets (points and lines in particular) to exposure calculation. Single positive numeric value functions as distance of buffer around SpatVector geometries. Environmental field acts as a field for rasterization utilizing sum function.\n\n\n\nListing 3: env_vect function\n\n\n\n\nCode\nenv_vect = function(env, env_buff, env_field, grid){\n\n  if (!is.null(env_buff)) { # create buffer around vector data\n    if (length(env_buff) == 1 && is.numeric(env_buff) && env_buff &gt; 0){\n      env_proj = terra::project(env, terra::crs(grid))\n      ## TERRA::BUFFER SOMETIMES CRASHES WITH BIG LINE VECTOR DATASETS\n      #env = terra::buffer(env_proj, env_buff)\n      ## TEMPORARY FIX: USE SF::ST_BUFFER\n      env = env_proj |&gt; sf::st_as_sf() |&gt; sf::st_buffer(env_buff) |&gt; terra::vect()\n    } else {\n      warning(\"Invalid env_buff argument - ignoring creation of buffer\")\n    }\n  }\n\n  if (!is.null(env_field)){ # choose field to rasterize\n    env_f_enq = rlang::enquo(env_field)\n    if (rlang::quo_name(env_f_enq) %in% terra::names(env)){\n      env = terra::rasterize(env, grid, field = rlang::quo_name(env_f_enq), fun = \"sum\")\n    } else {\n      warning(\"Invalid env_field argument - env_field is not a column name in data. Ignoring env_field argument\")\n      env = terra::rasterize(env, grid, fun = \"sum\")\n    }\n  } else {\n    env = terra::rasterize(env, grid, fun = \"sum\")\n  }\n  return(env)\n}\n\n\n\n\n\nBuffer around SpatVector bike routes lines San Diego data is calculated.\n\nif (any(class(env_data) != \"SpatRaster\")){\n  if (!is.null(env_buff)) { # create buffer around vector data\n    if (length(env_buff) == 1 && is.numeric(env_buff) && env_buff &gt; 0){\n      env_data_proj = terra::project(env_data, terra::crs(grid_rast))\n      ## TERRA::BUFFER SOMETIMES CRASHES WITH BIG LINE VECTOR DATASETS\n      #env_data = terra::buffer(env_data_proj, env_buff)\n      ## TEMPORARY FIX: USE SF::ST_BUFFER\n      env_data = env_data_proj |&gt; sf::st_as_sf() |&gt; sf::st_buffer(env_buff) |&gt; terra::vect()\n      \n    } else {\n      warning(\"Invalid env_buff argument - ignoring creation of buffer\")\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\nFigure 3: Calculated buffer around San Diego bike routes data\n\n\n\n\n\nAfterwards, buffer SpatVector is rasterized using class environmental field.\n\nif (!is.null(env_field)){ # choose field to rasterize\n  env_f_enq = rlang::enquo(env_field)\n  if (rlang::quo_name(env_f_enq) %in% terra::names(env_data)){\n    env_data = terra::rasterize(env_data, grid_rast, field = rlang::quo_name(env_f_enq), fun = \"sum\")\n  } else {\n    warning(\"Invalid env_field argument - env_field is not a column name in data. Ignoring env_field argument\")\n    env_data = terra::rasterize(env_data, grid_rast, fun = \"sum\")\n  }\n} else {\n  env_data = terra::rasterize(env_data, grid_rast, fun = \"sum\")\n}\n\n\n\n\n\n\n\n\n\nFigure 4: Rasterized San Diego bike routes lines buffer data\n\n\n\n\n\n\n\n4.5.2 Line Segment\nLine Segment requires assigning environmental data raster values to grid raster for further environmental exposure layer computation Section 4.9.2.\n\nif (!is.null(env_data)){ # env_data included\n  # project env_data to grid_rast cellsize\n  env_data_proj = terra::project(env_data, grid_rast)\n\n  # replace vals of grid with env values\n  terra::values(grid_rast) = terra::values(env_data_proj)\n}\n\n\n\n\n4.6 Group split\nGroup split argument enables splitting SpatVector GPS dataset into seperate SpatVectors by any field (day, movement type, participant ID etc.). Further output SpatRaster is calculated for each SpatVector data individually.\n\nif (is.null(group_split)) {\n  data_iter = list(data_proj) # only one item for for loop\n} else {\n  enq_group_split = rlang::enquo(group_split)\n  if (rlang::quo_name(enq_group_split) %in% terra::names(data_proj)){\n    data_iter = terra::split(data_proj, rlang::quo_name(enq_group_split)) # split data_proj by group_split\n    message(paste0(\"Data split by group into \", length(data_iter), \" items\"))\n  } else {\n    data_iter = list(data_proj)\n    warning(\"Invalid group_split argument - group_split is not a column in data. Data not split\")\n  }\n}\n\nData split by group into 8 items\n\n\n\n\n4.7 Activity Space Loop\nFollowing splitting the data, each SpatVector is iterated in first loop. Activity space SpatRasters (PO/KDE/DR) or buffer time data SpatVectors (LS) are computed.\n\n4.7.1 Point Overlay/Kernel Density Estimation/Density Ranking\nIn the beginning two empty lists destined to store loops results are generated. For extent and list discussion see Section 6.1. Activity space for each TWSA method is evaluated: PO - terra::rasterize(), KDE - spat_kde() and DR - spat_dr() (See Section 4.8). Every activity space SpatRaster is added as consecutive item in act_out list.\n\n##DR - change spat_kde\n# dr_rast =  spat_dr(data_i, grid_rast, bandwidth)\n##PO - change spat_kde\n# rast_points = terra::rasterize(data_i, grid_rast,  fun = \"length\")\n\nact_out = list()\noutput = list()\n\nfor (data_i in data_iter){\n  # if each group should have seperate extent then output is a list rasts\n  # if all groups should have same extent then output is rast with n layers\n\n  ### UNCOMMENT IF EVERY RAST SHOULD HAVE SEPERATE EXTENT\n  if (is.null(grid_extent)) {\n    #new ext for each group\n    # get extent\n    group_extent = terra::ext(data_i)\n    # new extent - expanded extent by bandwidth\n    new_group_extent = c(terra::xmin(group_extent) - bandwidth,\n                         terra::xmax(group_extent) + bandwidth,\n                         terra::ymin(group_extent) - bandwidth,\n                         terra::ymax(group_extent) + bandwidth)\n\n    # crop ext of each rast\n    grid_crop = terra::crop(grid_rast, new_group_extent)\n\n    kde_rast = spat_kde(data_i, grid_crop, bandwidth)\n  } else {\n    kde_rast =  spat_kde(data_i, grid_rast, bandwidth)\n  }\n  ### UNCOMMENT IF EVERY RAST SHOULD HAVE SEPERATE EXTENT\n\n\n  ### UNCOMMENT IF EVERY RAST SHOULD HAVE SAME EXTENT\n  #kde_rast = spat_kde(data_i, grid_rast, bandwidth)\n  ### UNCOMMENT IF EVERY RAST SHOULD HAVE SAME EXTENT\n  \n  # normalization without groups\n  if (normalize == TRUE && (norm_group == FALSE || norm_method != \"range\" || length(data_iter) == 1)){\n    if (norm_method != \"range\" && norm_group == TRUE) {\n      message(paste0('Norm_method is \"', norm_method, '\" - norm_group is TRUE is applicable only for norm_method \"range\". Norm group argument ignored. Normalizing each group seperately'))\n    }\n    # calculate normalization\n    terra::values(kde_rast) = BBmisc::normalize(terra::values(kde_rast),\n                                                method = norm_method, margin = 2L)\n  }\n\n  kde_rast = terra::subst(kde_rast, from = 0, to = NA)\n\n  ### UNCOMMENT IF EVERY RAST SHOULD BE A SEPERATE ELEMENT IN LIST\n  act_out[length(act_out) + 1] = as.list(kde_rast)\n  ### UNCOMMENT IF EVERY RAST SHOULD BE A SEPERATE ELEMENT IN LIST\n\n  ### UNCOMMENT IF ALL RAST AS STACK RASTER\n  #act_out = append(act_out, kde_rast)\n  ### UNCOMMENT IF ALL RAST AS STACK RASTER\n}\n\nif (normalize == TRUE && norm_method == \"range\" && norm_group == TRUE && length(data_iter) &gt; 1){\n\n  max_val = max(sapply(act_out, terra::minmax)[2,], na.rm = TRUE)\n\n  act_out = sapply(act_out, function(x) {\n    if (!(all(is.na(terra::values(x))))) {\n      terra::values(x) = BBmisc::normalize(terra::values(x), method = \"range\",\n                                           margin = 2L,\n                                           range = c(0, terra::minmax(x)[2] / max_val))\n    }\n    return(x)\n  })\n}\n\n\n\n\n\n\n\n\n\nFigure 5: PO, KDE and DR activity space for all days\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: PO, KDE and DR activity space for 20th August 2011, 21st August 2011 and 23rd August 2011\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncount\narea\nmin\nmax\nrange\nmean\nstd\nsum\n\n\n\n\nPO\n1091\n2729650.5\n1.0000000\n25.0000000\n24.0000000\n1.5609533\n1.9528579\n1703.0000000\n\n\nKDE\n19473\n48720776.9\n0.0000000\n0.0019976\n0.0019976\n0.0000350\n0.0001175\n0.6811803\n\n\nDR\n6858\n17158502.8\n0.0258368\n0.9994128\n0.9735760\n0.2210858\n0.1874312\n1516.2066941\n\n\nPO_20\n145\n362787.4\n1.0000000\n15.0000000\n14.0000000\n1.9586207\n1.9329301\n284.0000000\n\n\nKDE_20\n2092\n5234140.3\n0.0000000\n0.0015232\n0.0015232\n0.0000562\n0.0001512\n0.1175879\n\n\nDR_20\n622\n1556233.0\n0.0816327\n0.9591837\n0.8775510\n0.2381827\n0.1748179\n148.1496599\n\n\nPO_21\n157\n392811.8\n1.0000000\n14.0000000\n13.0000000\n1.4585987\n1.3472806\n229.0000000\n\n\nKDE_21\n1980\n4953934.1\n0.0000000\n0.0006602\n0.0006602\n0.0000469\n0.0000750\n0.0928017\n\n\nDR_21\n834\n2086656.6\n0.0043103\n0.9612069\n0.9568966\n0.2755830\n0.2262931\n229.8362069\n\n\nPO_23\n105\n262708.7\n1.0000000\n6.0000000\n5.0000000\n1.4095238\n0.8804246\n148.0000000\n\n\nKDE_23\n1344\n3362671.0\n0.0000000\n0.0005180\n0.0005180\n0.0000452\n0.0000699\n0.0607986\n\n\nDR_23\n629\n1573749.9\n0.0328947\n0.9868421\n0.9539474\n0.2575412\n0.2138723\n161.9934211\n\n\n\n\n\n\nTable 2: Table of statistics for PO, KDE and DR for all days, 20th August 2011, 21st August 2011 and 23rd August 2011\n\n\n\n\n\n\n4.7.2 Groups normalization\nWith implementation of group split argument two seperate groups normalization approaches are derived. First, normalization without groups is performed within activity space loop. It is applicable to all normalization methods. Each SpatRaster undergoes individual normalization using BBmisc:normalize(). Secondly, normalization with groups is conducted following activity space loop’s completion. SpatRaster with highest maximum value is rescaled to 0-1 range. Residual SpatRasters are rescaled in regards of prior SpatRaster. The latter approach is executed solely utilizing range normalization method. Therefore, whilst normalization method is distinct from range, the former is conducted instead.\n\n  if (normalize == TRUE && (norm_group == FALSE || norm_method != \"range\" || length(data_iter) == 1)){\n    if (norm_method != \"range\" && norm_group == TRUE) {\n      message(paste0('Norm_method is \"', norm_method, '\" - norm_group is TRUE is applicable only for norm_method \"range\". Norm group argument ignored. Normalizing each group seperately'))\n    }\n    # calculate normalization\n    terra::values(kde_rast) = BBmisc::normalize(terra::values(kde_rast),\n                                                method = norm_method, margin = 2L)\n  }\n\n\n\n\n\n\n\n\n\nFigure 7: Normalization without groups for PO, KDE and DR activity space for 20th August 2011, 21st August 2011 and 23rd August 2011\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmin\nmax\nrange\nmean\nstd\nsum\n\n\n\n\nPO_f_20\n0.0000000\n1\n1.0000000\n0.0684729\n0.1380664\n9.928571\n\n\nKDE_f_20\n0.0000000\n1\n1.0000000\n0.0369021\n0.0992412\n77.199191\n\n\nDR_f_20\n0.0851064\n1\n0.9148936\n0.2483182\n0.1822570\n154.453901\n\n\nPO_f_21\n0.0000000\n1\n1.0000000\n0.0352768\n0.1036370\n5.538462\n\n\nKDE_f_21\n0.0000001\n1\n0.9999999\n0.0709961\n0.1136578\n140.572211\n\n\nDR_f_21\n0.0044843\n1\n0.9955157\n0.2867052\n0.2354260\n239.112108\n\n\nPO_f_23\n0.0000000\n1\n1.0000000\n0.0819048\n0.1760849\n8.600000\n\n\nKDE_f_23\n0.0000002\n1\n0.9999998\n0.0873281\n0.1349004\n117.368978\n\n\nDR_f_23\n0.0333333\n1\n0.9666667\n0.2609751\n0.2167239\n164.153333\n\n\n\n\n\n\nTable 3: Table of statistics for normalization without groups for PO, KDE and DR for 20th August 2011, 21st August 2011 and 23rd August 2011\n\n\n\n\n\nif (normalize == TRUE && norm_method == \"range\" && norm_group == TRUE && length(data_iter) &gt; 1){\n\n  max_val = max(sapply(act_out, terra::minmax)[2,], na.rm = TRUE)\n\n  act_out = sapply(act_out, function(x) {\n    if (!(all(is.na(terra::values(x))))) {\n      terra::values(x) = BBmisc::normalize(terra::values(x), method = \"range\",\n                                           margin = 2L,\n                                           range = c(0, terra::minmax(x)[2] / max_val))\n    }\n    return(x)\n  })\n}\n\n\n\n\n\n\n\n\n\nFigure 8: Normalization with groups for PO, KDE and DR activity space for 20th August 2011, 21st August 2011 and 23rd August 2011\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmin\nmax\nrange\nmean\nstd\nsum\n\n\n\n\nPO_t_20\n0\n0.8823529\n0.8823529\n0.0604173\n0.1218233\n8.760504\n\n\nKDE_t_20\n0\n1.0000000\n1.0000000\n0.0369021\n0.0992412\n77.199187\n\n\nDR_t_20\n0\n0.9591837\n0.9591837\n0.1711129\n0.1910801\n106.432210\n\n\nPO_t_21\n0\n0.8235294\n0.8235294\n0.0290515\n0.0853481\n4.561086\n\n\nKDE_t_21\n0\n0.4334178\n0.4334178\n0.0307709\n0.0492613\n60.926389\n\n\nDR_t_21\n0\n0.9612069\n0.9612069\n0.2724946\n0.2273124\n227.260485\n\n\nPO_t_23\n0\n0.3529412\n0.3529412\n0.0289076\n0.0621476\n3.035294\n\n\nKDE_t_23\n0\n0.3400875\n0.3400875\n0.0296991\n0.0458780\n39.915647\n\n\nDR_t_23\n0\n0.9868421\n0.9868421\n0.2323929\n0.2212472\n146.175136\n\n\n\n\n\n\nTable 4: Table of statistics for normalization with groups for PO, KDE and DR for 20th August 2011, 21st August 2011 and 23rd August 2011\n\n\n\n\n\n\n4.7.3 Line segment\nIn the beginning, two empty lists destined to store loops results are generated. Selected extent and output option will be included as Section 6.1 discussion is resolved. Line Segment activity space loop is disparate from PO/KDE/DR loop. Line Segment method’s output is a list of buffer SpatVectors data. Additionally, it follows specific workflow Section 4.8.4. Here, time elapsed is calculated from time data and stored as attribute in buffer SpatVector. Line Segment method offers two ways of normalization (time_only_data argument) further discussed in Section 6.2.\n\nbuff_list = list()\noutput = list()\n\nfor (data_i in data_iter) {\n  # create line segments from spatial points\n  trajectories = terra::vect(trajectories_fun(data_i))\n\n  # create buffers over line segments\n  traj_buff = trajectories |&gt;\n    tidyterra::select(line_id) |&gt;\n    terra::buffer(bandwidth)\n\n  traj_buff$act = 1\n\n  if (!is.null(time_data)){\n    #time_data_null = dplyr::enquo(time_data)\n    duration_line_id = data_i |&gt;\n      dplyr::mutate(time_elapsed = as.numeric(difftime(dplyr::lead(.data[[time_cname]]),\n                                                       .data[[time_cname]], units = time_unit)),\n                    line_id = dplyr::row_number()) |&gt;\n      dplyr::select(line_id, time_elapsed)\n    \n      # last NA value set to 0 for normalization to not set lowest time value to 0\n      duration_line_id$time_elapsed[nrow(duration_line_id)] = 0\n\n    #1st type of normalize - normalize time_elapsed without spatial reference\n    if(normalize == TRUE && time_only_norm == TRUE &&\n       (norm_group == FALSE || norm_method != \"range\" || length(data_iter) == 1)) {\n\n      if (norm_method != \"range\" && norm_group == TRUE) {\n        message(paste0('Norm_method is \"', norm_method, '\" - norm_group is TRUE is applicable only for norm_method \"range\". Norm group argument ignored. Normalizing each group seperately'))\n      }\n\n      duration_line_id$time_elapsed = BBmisc::normalize(duration_line_id$time_elapsed, method = norm_method, margin = 1L)\n    }\n    \n    duration_df = as.data.frame(duration_line_id)\n\n    traj_buff = dplyr::left_join(traj_buff, duration_df, by = 'line_id')\n    traj_buff = traj_buff[,-2]\n    names(traj_buff)[2] = \"act\"\n  }\n\n  if(normalize == TRUE && (time_only_norm == FALSE || is.null(time_data)) &&\n     (norm_group == FALSE || length(data_iter) == 1)){\n    #2nd type of normalize - normalize time_elapsed or buffers using spatial reference - rasterizing and reading min max data from raster\n\n      if (norm_method != \"range\") {\n        message(paste0('Norm_method is \"', norm_method, '\" - time_only_norm is FALSE or time_data is missing. This type of time_only normalization is applicable only for norm_method \"range\". Setting norm_method to \"range\"'))\n      }\n\n    # slightly varying output values (max very close to 1)\n\n    norm_rast = terra::rasterize(traj_buff, grid_rast, field = \"act\", fun = \"sum\")\n    #read max val\n    max_norm = terra::minmax(norm_rast)[2]\n\n    # normalize\n    if (length(unique(traj_buff$act)) == 1){\n      #if vector is constant adjust BBmisc\n      traj_buff$act = BBmisc::normalize(traj_buff$act, method = \"range\",\n                                        margin = 1L, range = c(0, max(traj_buff$act) / max_norm * 2))\n    } else{\n      traj_buff$act = BBmisc::normalize(traj_buff$act, method = \"range\",\n                                        margin = 1L, range = c(0, max(traj_buff$act) / max_norm))\n    }\n  }\n  \n  buff_list[length(buff_list) + 1] = list(traj_buff)\n}\n\n\n\n\n\n\n\n\n\nFigure 9: Activity space for Line Segment method with and without time_data\n\n\n\n\n\nLine Segment group normalization is conducted analogously to PO, KDE and DR activity space loop, with the exception of Line Segment adjustment. Rather than normalizing SpatRaster values, time elapsed attribute is processed.\n\nif(normalize == TRUE && time_only_norm == TRUE && !missing(time_data) &&\n   norm_group == TRUE && length(data_iter) &gt; 1 && norm_method == \"range\"){\n  # 1st normalize variant for all rasts\n\n\n  if (length(data_iter) &gt; 1){\n\n    max_buff = (do.call(rbind, buff_list))$act |&gt; max(na.rm = TRUE)\n    buff_list = sapply(buff_list, function(x) {\n      if (!(all(is.na(x$act)))) {\n        x$act = BBmisc::normalize(x$act, method = \"range\",\n                                             margin = 2L,\n                                             range = c(0, max(x$act, na.rm = TRUE) / max_buff))\n      }\n      return(x)\n    })\n\n  } else {\n\n    max_buff = buff_list[[1]]$act |&gt; max(na.rm = TRUE)\n    buff_list = sapply(buff_list, function(x) {\n      if (!(all(is.na(x$act)))) {\n        x$act = BBmisc::normalize(x$act, method = \"range\",\n                                             margin = 2L,\n                                             range = c(0, max(x$act, na.rm = TRUE) / max_buff))\n      }\n      return(x)\n    })\n  }\n} else if (normalize == TRUE && (time_only_norm == FALSE || missing(time_data)) &&\n           norm_group == TRUE && length(data_iter) &gt; 1 && norm_method == \"range\"){\n  # 2nd normalize variant for all rasts\n\n  norm_list = sapply(buff_list, terra::rasterize, grid_rast, field = \"act\", fun = \"sum\")\n  max_multiple_norm = max(sapply(norm_list, terra::minmax)[2,], na.rm = TRUE)\n  buff_list = sapply(buff_list, function(x) {\n    if (!(all(is.na(x$act)))) {\n      x$act = BBmisc::normalize(x$act, method = \"range\",\n                                margin = 2L,\n                                range = c(0, max(x$act, na.rm = TRUE) / max_multiple_norm))\n    }\n    return(x)\n  })\n}\n\n\n\n\n4.8 Method specific calculations\n\n4.8.1 Point Overlay\nActivity space of Point Overlay method is evaluated by converting points vector data to raster using length function.\n\nrast_points = terra::rasterize(data_i, grid_rast, fun = \"length\")\n\n\n\n4.8.2 Kernel Density Estimation\nThe spat_kde() implemented in exposure_KDE() utilizes kde() function. GPS SpatVector points (x), grid rast (ref) and bandwidth (bw) are processed for the purpose of computing Kernel Density Estimation SpatRaster.\n\n\n\nListing 4: spat_kde function\n\n\n\n\nCode\nspat_kde = function(x, ref, bw){\n\n  # coords of each ref cell center\n  gx = terra::crds(ref)[,1] |&gt; unique()\n  gy = terra::crds(ref)[,2] |&gt; unique()\n\n  # distance from each x/y ref cell center to each x/y x points (squared)\n\n  kde_val = kde(x, gx, gy, bw)\n\n  output_list = list(x = gx, y = gy, z = kde_val)\n\n  # create df of x/y coords and val\n  pts = data.frame(expand.grid(x = output_list$x, y = output_list$y),\n                   z = as.vector(array(output_list$z,  length(output_list$z))))\n  # create points SpatVector\n  pts = terra::vect(pts, geom = c(\"x\", \"y\"))\n  # rasterize to ref\n  return(terra::rasterize(pts, ref, field = \"z\"))\n}\n\n\n\n\n\nThe kde() function produces KDE exposure matrix from SpatVector points, two numeric vectors indicating columns and rows coordinates of SpatRaster and bandwidth. With the intention of optimazing memory efficiency, computation of each column is performed seperately.\n\n\n\nListing 5: kde function\n\n\n\n\nCode\nkde = function(points, ref_uq_x, ref_uq_y, bw) {\n  ax &lt;- outer(ref_uq_x, terra::crds(points)[, 1], \"-\" ) ^ 2\n  ay &lt;- outer(ref_uq_y, terra::crds(points)[, 2], \"-\" ) ^ 2\n\n  # points within quadratic search radius\n  ax_T = ax &lt;= bw ^ 2\n  ay_T = ay &lt;= bw ^ 2\n\n  # every x row index\n  positions = matrix(1:nrow(ax), ncol = 1)\n\n  # calculate KDE for each column seperately\n\n  density_mx = apply(positions,  1, function(xcol) {\n\n    # which point's x coord within possible search radius\n    cols_T = which(ax_T[xcol,] == TRUE)\n\n    # matrix cell coordinates of points within quadratic search radius\n    rows_T = which(ay_T[,cols_T] == TRUE, arr.ind = TRUE)\n\n    if (length(cols_T) &lt;= 1){ # if only one or zero points within quadratic search radius\n      suppressWarnings({rows_T = rows_T |&gt; array(dim = c(length(rows_T), 1)) |&gt; cbind(1)})\n      colnames(rows_T) = c(\"row\", \"col\")\n    }\n    # calculate distance within quadratic search radius\n    df_row = rows_T |&gt; as.data.frame() |&gt;\n      dplyr::mutate(sum_val = ay[cbind(row, cols_T[col])] + ax[cbind(xcol, cols_T[col])]) |&gt;\n      dplyr::filter(sum_val &lt;= bw ^ 2) |&gt; # filter points within search radius based on real distance\n      dplyr::mutate(sum_val = (sum_val / bw ^ 2 * (-1) + 1) ^ 2) # calculate impact of each point on cells\n\n    #create empty matrix\n    empty_mx = matrix(NA, nrow = nrow(ay), ncol = length(cols_T))\n    # insert values based on cell coordinates\n    empty_mx[cbind(df_row$row, df_row$col)] = df_row$sum_val\n\n    # sum impact of every point to calculate KDE\n    mx_sum = rowSums(empty_mx, na.rm = TRUE)\n\n    return(mx_sum)})\n\n  # transpose matrix and final KDE calculations\n  out = t(density_mx) * (3/pi) / bw ^ 2\n  return(out)\n}\n\n\n\n\n\nCalculations are conducted on seven sample GPS Geolife Data SpatVector points located in center of San Diego and cropped to sample GPS data extent 5 x 5 grid raster.\n\n\n\n\nListing 6: Example kde data\n\n\n#example ref grid and points\nexp_point = geolife_sandiego |&gt; filter(dateTime %in% c(\"2011-08-18 02:27:11\", \"2011-08-19 04:24:54\", \"2011-08-21 03:57:00\", \"2011-08-18 03:16:43\", \"2011-08-18 01:26:31\", \"2011-08-21 04:24:11\", \"2011-08-21 03:03:14\")) |&gt; vect(geom = c(\"lon\", \"lat\"), crs = \"EPSG:4326\") |&gt; project(crs(data_proj))\nref_exp = crop(grid_rast, ext(exp_point))\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Example data\n\n\n\n\n\nX coordinates matrix\n\n\n\n\n\n\nExample points coordinates\n\n\nx\ny\n\n\n\n\n484833.2\n3619702\n\n\n484817.4\n3619649\n\n\n484957.7\n3619852\n\n\n484988.0\n3619654\n\n\n484856.3\n3619633\n\n\n484761.3\n3619643\n\n\n484884.0\n3619700\n\n\n\n\n\n\n\n\n\n\\begin{bmatrix} 484763 &484813 &484863 &484913 &484963 \\\\484763 &484813 &484863 &484913 &484963 \\\\484763 &484813 &484863 &484913 &484963 \\\\484763 &484813 &484863 &484913 &484963 \\\\484763 &484813 &484863 &484913 &484963 \\\\ \\end{bmatrix}\n\n\n\nY coordinates matrix\n\n\n\n\\begin{bmatrix} 3619850 &3619850 &3619850 &3619850 &3619850 \\\\3619800 &3619800 &3619800 &3619800 &3619800 \\\\3619750 &3619750 &3619750 &3619750 &3619750 \\\\3619700 &3619700 &3619700 &3619700 &3619700 \\\\3619650 &3619650 &3619650 &3619650 &3619650 \\\\ \\end{bmatrix}\n\n\nColumn and rows coordinates are retrieved from ref SpatRaster. Subsequently, distance matrixes from every SpatVector point to each column and row is computed.\n\n#points to row and col distance matrixes\ngx = terra::crds(ref_exp)[,1] |&gt; unique()\ngy = terra::crds(ref_exp)[,2] |&gt; unique()\n\n# distance matrixes\nax = abs(outer(gx, terra::crds(exp_point)[, 1], \"-\" ))\nay = abs(outer(gy, terra::crds(exp_point)[, 2], \"-\" ))\n\n# used in further calculation\nax &lt;- outer(gx, terra::crds(exp_point)[, 1], \"-\" ) ^ 2\nay &lt;- outer(gy, terra::crds(exp_point)[, 2], \"-\" ) ^ 2\n\n\nDistance matrix from SpatVector points to columns\n\n\n\n\\begin{bmatrix} 70 &54 &195 &225 &93 &2 &121 \\\\20 &4 &145 &175 &43 &52 &71 \\\\30 &46 &95 &125 &7 &102 &21 \\\\80 &96 &45 &75 &57 &152 &29 \\\\130 &146 &5 &25 &107 &202 &79 \\\\ \\end{bmatrix}\n\n\n\nDistance matrix from SpatVector points to rows\n\n\n\n\\begin{bmatrix} 148 &201 &2 &196 &217 &207 &150 \\\\98 &151 &52 &146 &167 &157 &100 \\\\48 &101 &102 &96 &117 &107 &50 \\\\2 &51 &152 &46 &67 &57 &0 \\\\52 &1 &202 &4 &17 &7 &50 \\\\ \\end{bmatrix}\n\n\nSpatVector points within search radius (bandwidth) are indicated. Based on distance matrix boolean matrix is derived.\n\n# matrixes with points within search radius T/F\nax_T = ax &lt;= 100 \nay_T = ay &lt;= 100 \n\n# used in further calculation\nax_T = ax &lt;= 100 ^ 2\nay_T = ay &lt;= 100 ^ 2\n\n\nSearch radius of columns matrix\n\n\n\n\\begin{bmatrix} TRUE &TRUE &FALSE &FALSE &TRUE &TRUE &FALSE \\\\TRUE &TRUE &FALSE &FALSE &TRUE &TRUE &TRUE \\\\TRUE &TRUE &TRUE &FALSE &TRUE &FALSE &TRUE \\\\TRUE &TRUE &TRUE &TRUE &TRUE &FALSE &TRUE \\\\FALSE &FALSE &TRUE &TRUE &FALSE &FALSE &TRUE \\\\ \\end{bmatrix}\n\n\n\nSearch radius of rows matrix\n\n\n\n\\begin{bmatrix} FALSE &FALSE &TRUE &FALSE &FALSE &FALSE &FALSE \\\\TRUE &FALSE &TRUE &FALSE &FALSE &FALSE &FALSE \\\\TRUE &FALSE &FALSE &TRUE &FALSE &FALSE &TRUE \\\\TRUE &TRUE &FALSE &TRUE &TRUE &TRUE &TRUE \\\\TRUE &TRUE &FALSE &TRUE &TRUE &TRUE &TRUE \\\\ \\end{bmatrix}\n\n\nCalculations are performed on every column seperately. Retrieve points within search radius of current column and all rows and generate matrix of retrieved points coordinates in rows boolean matrix.\n\n\n\n\nPoints within row and column search radius\n\n\nrow\ncol\nsum_val\n\n\n\n\n2\n1\n120.624429\n\n\n3\n1\n85.065152\n\n\n4\n1\n70.156307\n\n\n5\n1\n87.222329\n\n\n4\n2\n74.716808\n\n\n5\n2\n54.413731\n\n\n4\n3\n114.849433\n\n\n5\n3\n94.808043\n\n\n4\n4\n56.811929\n\n\n5\n4\n7.005758\n\n\n\n\n\nxcol = 1\n\n# select points with x coord within possible search radius to single column\ncols_T = which(ax_T[xcol, ] == TRUE)\n## [1] 1 2 5 6\n\n# matrix cell coordinates of points within quadratic search radius\nrows_T = which(ay_T[,cols_T] == TRUE, arr.ind = TRUE)\n\nCompute euclidean distance and indicate points within euclidean search radius. Points beyond search radius are removed.\n\n\n\n\n\nPoints within euclidean search radius\n\n\nrow\ncol\nsum_val\n\n\n\n\n3\n1\n85.065152\n\n\n4\n1\n70.156307\n\n\n5\n1\n87.222329\n\n\n4\n2\n74.716808\n\n\n5\n2\n54.413731\n\n\n5\n3\n94.808043\n\n\n4\n4\n56.811929\n\n\n5\n4\n7.005758\n\n\n\n\n\n\n\n\ndist = rows_T |&gt; as.data.frame() |&gt;\n      dplyr::mutate(sum_val = ay[cbind(row, cols_T[col])] + ax[cbind(xcol, cols_T[col])])\n\n#filter search radius again\ndist_filt = dist |&gt; dplyr::filter(sum_val &lt;= 100 ^ 2)\n\nFurther, impact of selected points on value of each cell is evaluated.\n\n# kde calculations\ndf_row = dist_filt |&gt; dplyr::mutate(sum_val = (sum_val / 100 ^ 2 * (-1) + 1) ^ 2)\n\n\n\n\n\nImpact of points on each cell value\n\n\nrow\ncol\nsum_val\n\n\n\n\n3\n1\n0.0763925\n\n\n4\n1\n0.2578702\n\n\n5\n1\n0.0572293\n\n\n4\n2\n0.1951341\n\n\n5\n2\n0.4954957\n\n\n5\n3\n0.0102300\n\n\n4\n4\n0.4586547\n\n\n5\n4\n0.9902080\n\n\n\n\nEmpty matrix with ay number of rows and indicated points number of columns is generated. Point impact values are inserted into empty matrix.\n\n#create empty matrix\nempty_mx = matrix(NA, nrow = nrow(ay), ncol = length(cols_T))\n# insert values based on cell coordinates\nempty_mx[cbind(df_row$row, df_row$col)] = df_row$sum_val\n\n\nMatrix of every column impacting point\n\n\n\n\\begin{bmatrix} NA &NA &NA &NA \\\\NA &NA &NA &NA \\\\0.08 &NA &NA &NA \\\\0.26 &0.2 &NA &0.46 \\\\0.06 &0.5 &0.01 &0.99 \\\\ \\end{bmatrix}\n\n\nRows of matrix are summed to evaluate entire points impact on each cell.\n\n# sum all points to calc cell value\nmx_sum = rowSums(empty_mx, na.rm = TRUE)\n\n\n\n\\begin{bmatrix} 0 \\\\0 \\\\0.076 \\\\0.912 \\\\1.553 \\\\ \\end{bmatrix}\n\n\nEvaluation is repeated for every column in ref SpatRaster computing values for all cells.\n\n\n\\begin{bmatrix} 0 &0 &0.01 &0.64 &0.99 \\\\0 &0 &0 &0.28 &0.53 \\\\0.08 &0.59 &0.96 &0.46 &0.02 \\\\0.91 &2.01 &2.32 &1.07 &0.67 \\\\1.55 &2.68 &2.47 &1.07 &0.89 \\\\ \\end{bmatrix}\n\n\nFinal KDE calculations are performed and output matrix is returned.\n\nout_kde = t(density_mx) * (3/pi) / 100 ^ 2\n\n\n\n\\begin{bmatrix} 0 &0 &0.000001 &0.000061 &0.000095 \\\\0 &0 &0 &0.000027 &0.00005 \\\\0.000007 &0.000056 &0.000091 &0.000044 &0.000002 \\\\0.000087 &0.000192 &0.000222 &0.000102 &0.000064 \\\\0.000148 &0.000256 &0.000236 &0.000102 &0.000085 \\\\ \\end{bmatrix}\n\n\nMatrix values are converted into ref SpatRaster.\n\noutput_list = list(x = gx, y = gy, z = out_kde)\n\n# create df of x/y coords and val\npts = data.frame(expand.grid(x = output_list$x, y = output_list$y),\n                 z = as.vector(array(output_list$z,  length(output_list$z))))\n# create points SpatVector\npts = terra::vect(pts, geom = c(\"x\", \"y\"))\n# rasterize to ref\nout_rast = terra::rasterize(pts, ref_exp, field = \"z\")\nout_rast = terra::subst(out_rast, from = 0, to = NA)\n\n\n\n\n\n\n\n\n\nFigure 11: Kernel Density Estimation for example data\n\n\n\n\n\n\n4.8.3 Density Ranking\nThe spat_dr() function implemented in exposure_DR() uses kde() and kde_points() functions to process GPS points (x), grid raster (ref) and bandwidth (bw) into Density Ranking SpatRaster. It utilizes stats::ecdf() to calculate DR from KDE ref raster values and KDE points values.\n\n\n\nListing 7: spat_dr function\n\n\n\n\nCode\nspat_dr = function(x, ref, bw) {\n  gx = terra::crds(ref)[,1] |&gt; unique()\n  gy = terra::crds(ref)[,2] |&gt; unique()\n\n  # distance from each x/y ref cell center to each x/y x points (squared)\n\n  kde_val = kde(x, gx, gy, bw)\n  dr_val = kde_points(terra::crds(x)[,1], terra::crds(x)[,2], bw)\n  # DR EVAL\n  dr_calc = stats::ecdf(dr_val)(as.vector(kde_val))\n\n  output_list = list(x = gx, y = gy, z = dr_calc)\n\n  # create df of x/y coords and val\n  pts = data.frame(expand.grid(x = output_list$x, y = output_list$y),\n                   z = output_list$z)\n  # create points SpatVector\n  pts = terra::vect(pts, geom = c(\"x\", \"y\"))\n  # rasterize to ref\n  return(terra::rasterize(pts, ref, field = \"z\"))\n}\n\n\n\n\n\nThe kde_points() calculates KDE of every SpatVector point (instead of cells as in kde()). Function utilizes two vectors of SpatVector point’s x and y coordinates and bandwidth. Similarly to kde(), kde_points() computation is segmented into seperate points to optimize memory efficiency. Calculations are executed on example data produced beforehand in Listing 6.\n\n\n\nListing 8: kde_points function\n\n\n\n\nCode\nkde_points = function(vect_x, vect_y, bw){\n  # apply for each cell coords seperately\n  kde_p = mapply(function(x, y) {\n    #distance betweeen each point\n    ax_p = (vect_x - x) ^ 2\n    ay_p = (vect_y - y) ^ 2\n\n    # boolean if dist within search radius\n    ax_p_T = ax_p &lt;= bw ^ 2\n    ay_p_T = ay_p &lt;= bw ^ 2\n\n    # choose dist^ 2 within search radius\n    x_T = which(ax_p_T == TRUE)\n    y_T = which(ay_p_T == TRUE)\n\n    # index of coords of which both x and y within search radius\n    xy_T = intersect(x_T, y_T)\n\n    # calculate dist ^ 2 and choose thoso within search radius\n    xy_val = ax_p[xy_T] + ay_p[xy_T]\n    xy_val = xy_val[xy_val &lt; bw ^ 2]\n\n    #\n    xy_calc = (xy_val / bw ^ 2 * (-1) + 1) ^ 2\n\n    xy_out = sum(xy_calc)\n\n\n  }, x = vect_x, y =  vect_y) * (3/pi) / bw ^ 2\n  \n  return(kde_p)\n}\n\n\n\n\n\n\n# same example points as in kde()\n\nvect_x = terra::crds(exp_point)[,1]\n## [1] 484833.2 484817.4 484957.7 484988.0 484856.3 484761.3 484884.0\n\nvect_y = terra::crds(exp_point)[,2]\n## [1] 3619702 3619649 3619852 3619654 3619633 3619643 3619700\n\nFirst pair of coordinates is retrieved.\n\nxi = vect_x[1]\n## [1] 484833.2\n\nyi = vect_y[1]\n## [1] 3619702\n\nInitially, distance between current point and each point’s x and y coordinates is derived.\n\n# distance between each point's row and column\n\nabs(vect_x - xi)\n## [1]   0.00000  15.73158 124.58766 154.83885  23.13644  71.87595  50.88448\n\nabs(vect_y - yi)\n## [1]   0.000000  53.075746 150.130624  48.124734  68.876543  58.643418   1.962094\n\n# used in further calculation\nax_p = (vect_x - xi) ^ 2\nay_p = (vect_y - yi) ^ 2\n\nIndicate points within search radius (bandwidth). Based on point distance vector boolean vector is derived.\n\n# points within search radius in x and y\n\nax_p_T = ax_p &lt;= 100 ^ 2\n## [1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n\nay_p_T = ay_p &lt;= 100 ^ 2\n## [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n\nAfterwards, retrieve points within search radius of current point x and y coordinates and generate vector of retrieved points indexes in x and y coordinates vectors.\n\n# intersect x and y to get indexes of point coords within search radius\n\nx_T = which(ax_p_T == TRUE)\n## [1] 1 2 5 6 7\n\ny_T = which(ay_p_T == TRUE)\n## [1] 1 2 4 5 6 7\n\nxy_T = intersect(x_T, y_T)\n## [1] 1 2 5 6 7\n\nCompute euclidean distance and indicate points within euclidean search radius. Points beyond search radius are removed.\n\n# calc dist and search radius filter again\nxy_val = sqrt(ax_p[xy_T] + ay_p[xy_T])\n## [1]  0.00000 55.35808 72.65860 92.76423 50.92230\n\nxy_val[xy_val &lt; 100]\n## [1]  0.00000 55.35808 72.65860 92.76423 50.92230\n\n# used in further calculation\nxy_val = ax_p[xy_T] + ay_p[xy_T]\nxy_val = xy_val[xy_val &lt; 100 ^ 2]\n\nProcess impact of points calculations and sum all values to compute entire points impact on current point.\n\n# additional calc and sum all rows \nxy_calc = (xy_val / 100 ^ 2 * (-1) + 1) ^ 2\n## [1] 1.00000000 0.48100918 0.22285265 0.01945458 0.54862461\n\nxy_out = sum(xy_calc)\n## [1] 2.271941\n\nEvaluation is repeated for all points and final KDE calculations are performed.\n\nkde_p\n## [1] 2.271941 2.711617 1.000000 1.000000 2.135161 1.491677 1.861494\nkde_p_out = kde_p * (3/pi) / 100 ^ 2\n## [1] 0.00022 0.00026 0.00010 0.00010 0.00020 0.00014 0.00018\n\nFormerly computated grid KDE and point KDE are utilized in Density Ranking using Empiracal Cumulative Distribution Function, ranking KDE values.\n\ndr_calc = stats::ecdf(kde_p_out)(as.vector(out_kde))\n##  [1] 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.57 0.86 0.29 0.00\n## [21] 0.43 0.86 0.86 0.29 0.00\n\n\n\n\\begin{bmatrix} 0 &0 &0 &0 &0 \\\\0 &0 &0 &0 &0 \\\\0 &0 &0 &0 &0 \\\\0 &0.57 &0.86 &0.29 &0 \\\\0.43 &0.86 &0.86 &0.29 &0 \\\\ \\end{bmatrix}\n\n\nVector values are converted into ref SpatRaster.\n\noutput_dr_list = list(x = gx, y = gy, z = dr_calc)\n\n# create df of x/y coords and val\npts_dr = data.frame(expand.grid(x = output_dr_list$x, y = output_dr_list$y),\n                 z = output_dr_list$z)\n# create points SpatVector\npts_dr = terra::vect(pts_dr, geom = c(\"x\", \"y\"))\n# rasterize to ref\ndr_out_rast = terra::rasterize(pts_dr, ref_exp, field = \"z\")\ndr_out_rast = terra::subst(dr_out_rast, from = 0, to = NA)\n\n\n\n\n\n\n\n\n\nFigure 12: Density Ranking for example data\n\n\n\n\n\n\n4.8.4 Line Segment\nThe expoosure_LS() function applies trajectories_fun() to evaluate trajectories from every two GPS data SpatVector points (ordered).\n\n\n\nListing 9: tracjectories_fun function\n\n\n\n#Line segment trajectories\n\ntrajectories_fun = function(data){\n\n  t_name = c(names(data))[grepl('time', c(names(data)))]\n  lst_name = paste(t_name[which.max(nchar(t_name))], \"_1\", sep = \"\")\n\n  trajectories_out = data |&gt;\n    sf::st_as_sf() |&gt; # change to sf object to change points to linestring later\n    #filter to the study id defined by the argument\n    #define start and end points of line\n    dplyr::mutate(\n      line_id = dplyr::row_number(),#an id for each \"line segment\"\n      x_start= sf::st_coordinates(geometry)[,1],\n      y_start= sf::st_coordinates(geometry)[,2],\n      x_end = dplyr::lead(x_start),\n      y_end = dplyr::lead(y_start)\n    ) |&gt;\n    dplyr::ungroup() |&gt;\n    sf::st_set_geometry(NULL) |&gt;\n    #exclude the last observation, which has no \"lead\", and will be missing.\n    dplyr::filter(is.na(x_end)==FALSE) |&gt;\n    # Make the data long form so that each point has two observations\n    tidyr::pivot_longer(\n      # select variables to pivot longer.\n      cols = c(x_start, y_start, x_end, y_end),\n      #value goes to \"x/y\", and time goes to \"_start/end\"\n      names_to = c(\".value\", lst_name),\n      names_repair = \"unique\",\n      names_sep = \"_\"#the separator for the column name\n    ) |&gt;\n    # create sf object once again\n    sf::st_as_sf(coords = c(\"x\", \"y\"), crs= sf::st_crs(data)) |&gt;\n    dplyr::group_by(line_id) |&gt;\n    #see Edzer's answer here:https://github.com/r-spatial/sf/issues/851\n    #do_union=FALSE is needed.\n    dplyr::summarize(do_union = FALSE) |&gt;\n    sf::st_cast(\"LINESTRING\") |&gt; # cast linestring type\n    sf::st_as_sf() |&gt;\n    dplyr::ungroup()\n\n  return(trajectories_out)\n}\n\n\n\n\nSubsequently, buffer around all trajectories is evaluated, later applied in normalization and output SpatRaster calculations.\n\n# create line segments from spatial points\ntrajectories = terra::vect(trajectories_fun(data_i))\n\n# create buffers over line segments\ntraj_buff = trajectories |&gt;\n  tidyterra::select(line_id) |&gt;\n  terra::buffer(bandwidth)\n\ntraj_buff$act = 1\n\n\n\n\n\n\n\n\n\nFigure 13: Line Segment buffers with trajectories\n\n\n\n\n\n\n\n4.9 Environmental exposure loop\n\n4.9.1 Point Overlay/Kernel Density Estimation/Density Ranking\nSecond, environmental exposure, loop for calculating environmental exposure is implemented. Environmental exposure layer is computed by multiplying activity space layer and environmental data layer.\n\nfor (out in act_out) {\n  if (!is.null(env_data)){ # calculate exposure\n    # project env_data to grid\n    env_data_proj = terra::project(env_data, out)\n    # if same ext for groups out -&gt; grid_rast and this code chunk out of loop\n\n    #env_data_resamp = terra::resample(env_data_proj, out)\n\n    rast_env_kde = out * env_data_proj\n    end_rast = rast_env_kde\n  } else {\n    end_rast = out\n  }\n  if (length(data_iter) == 1) { # if one group or no group output is not a list\n    output = end_rast\n  } else {\n    output[length(output) + 1] = as.list(end_rast)\n  }\n}\n\n\n\n4.9.2 Line Segment\nComputing environmental exposure layer in Line Segment method utilizes grid raster with assigned environmental data values. Grid raster is extracted to every SpatVector trajectory buffer, converted to one data frame and summarized by area overlap for each segment afterwards. Summarized exposure data is joined with SpatVector trajectory buffer and multiplied by normalized or not normalized time weights. Finally, vector data is converted to raster based on exposure and time weights with sum function. Activity space calculation bypasses extraction of environmental values and rasterizes time weights to grid raster using sum function.\n\nfor (buff in buff_list) {\n\n  if (!missing(env_data)){ #all of computation necessary only when calculating env_data\n    # extract values and weights (area overlap) from grid for each cell of buffer\n    exac_extr = exactextractr::exact_extract(grid_rast, sf::st_as_sf(buff), progress = FALSE)\n\n    traj_extract = Map(function(x, id) {x$line_id = id\n    return(x)}, x = exac_extr, seq_along(exac_extr)) |&gt; dplyr::bind_rows() |&gt;\n      dplyr::as_tibble() |&gt;\n      dplyr::relocate(line_id) |&gt;\n      dplyr::rename(e = 2)\n\n    # calculate summarised exposure for each buffer\n    traj_extract_line_id = traj_extract |&gt;\n      dplyr::group_by(line_id) |&gt;\n      dplyr::summarise(\n        #Jan 9, 2024 use R's built-in weighted.mean() function\n        #instead of calculating weighted average manually\n        end_weights=stats::weighted.mean(\n          x=e,\n          w=coverage_fraction,\n          na.rm=TRUE),\n        #These weights are based on the areal overlap, not time\n        sum_weights = sum(coverage_fraction,na.rm=TRUE),\n        n_pixel = dplyr::n() # number of observations corresponds to number of pixels per line segment\n      ) |&gt;\n      dplyr::ungroup()\n\n    # join weights with spatial buffer\n    weight_buff = dplyr::inner_join(buff, traj_extract_line_id, by = 'line_id')\n\n    weight_buff$end_weights = weight_buff$end_weights * weight_buff$act\n\n    # rasterize results\n    rast_segment = terra::rasterize(weight_buff, grid_rast, field = \"end_weights\", fun = \"sum\")\n  } else {\n    rast_segment = terra::rasterize(buff, grid_rast, field = \"act\", fun = \"sum\")\n  }\n  if (length(data_iter) == 1) { # if one group or no group output is not a list\n    output = rast_segment\n  } else {\n    output[length(output) + 1] = as.list(rast_segment)\n  }\n}\n\n\n\n\n\n\n\n\n\nline_id\ne\ncoverage_fraction\n\n\n\n\n1\n0.1509941\n0.2779211\n\n\n1\n0.3074401\n0.8561569\n\n\n1\n0.2196989\n1.0000000\n\n\n1\n0.2476714\n1.0000000\n\n\n1\n0.2691399\n0.8558987\n\n\n1\n0.2917317\n0.2785110\n\n\n1\n0.0974092\n0.2394574\n\n\n1\n0.0545777\n0.9830808\n\n\n1\n0.1115729\n1.0000000\n\n\n1\n0.2017748\n1.0000000\n\n\n\n\n\n\nTable 5: traj_extract - Extracted values for each raster cell\n\n\n\n\n\n\n\n\n\n\n\n\nline_id\nend_weights\nsum_weights\nn_pixel\n\n\n\n\n1\n0.1818593\n104.5210\n127\n\n\n2\n0.1825086\n107.2911\n132\n\n\n3\n0.1844797\n107.2188\n135\n\n\n4\n0.1678028\n105.7782\n135\n\n\n5\n0.1756642\n109.1286\n137\n\n\n6\n0.2133048\n111.2900\n142\n\n\n7\n0.1915245\n109.1738\n137\n\n\n8\n0.1610415\n110.9404\n138\n\n\n9\n0.1730885\n110.1454\n137\n\n\n10\n0.1926440\n103.0547\n128\n\n\n\n\n\n\nTable 6: traj_extract_line_id - Extracted values for each line segment with weights\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Weighted line segments buffers\n\n\n\n\n\n\n\n4.10 Writing to filepath\nSplitting SpatVector data imposes adjusting filepaths for writing multiple output SpatRasters. In scenarios where number of groups is greater than 1 unique filepaths based on set path are created.\n\nif (length(data_iter) &gt; 1 && !is.null(filepath)) {   \n  # list output \n  \n  # for iterating file names   \n  file_ext = stringi::stri_extract(filepath, regex = \"\\\\.(\\\\w+)$\")   \n  file_no_ext = substr(filepath, 1, nchar(filepath) - nchar(file_ext))\n  \n  file_vect = rep(file_no_ext, length.out = length(data_iter))   \n  file_vect = paste0(file_vect, \"_\", seq_along(file_vect), file_ext) \n}\n\n# for filepath = \"raster.tif\"\nfile_vect\n## [1] \"raster_1.tif\" \"raster_2.tif\" \"raster_3.tif\" \"raster_4.tif\" \"raster_5.tif\" \"raster_6.tif\" \"raster_7.tif\" \"raster_8.tif\"\n\nWrite every output SpatRaster to filepaths defined beforehand.\n\nif (!is.null(filepath)) { # save raster\n  if (length(data_iter) &gt; 1){ # update filepath\n\n    mapply(function(x, y) {\n      terra::writeRaster(x, filename = y)\n      message(paste0(\"Saving output to \", y))\n    }, x = output, y = file_vect)\n\n  } else {\n\n    terra::writeRaster(end_rast, filename = filepath)\n    message(paste0(\"Saving output to \", filepath))\n  }\n}\n\n\n\n4.11 Output\nOutput of twsagps package functions is a single SpatRaster or a list of activity space or environmental exposure SpatRasters.\n\n\n\n\n\n\n\n\nFigure 15: Environmental exposure layers for NDVI data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncount\narea\nmin\nmax\nrange\nmean\nstd\nsum\n\n\n\n\nPO_ndvi\n1091\n2729650\n-0.4050649\n1.0608427\n1.4659077\n0.1067366\n0.1088869\n116.4496332\n\n\nKDE_ndvi\n19473\n48720777\n-0.0000137\n0.0002946\n0.0003083\n0.0000028\n0.0000074\n0.0549635\n\n\nDR_ndvi\n6858\n17158503\n-0.0561597\n0.1809338\n0.2370935\n0.0183426\n0.0196866\n125.7934349\n\n\nLS_ndvi\n20904\n52301083\n-0.0810223\n527.6416016\n527.7226238\n2.5270035\n26.2159897\n52824.4801867\n\n\n\n\n\n\nTable 7: Table of statistics for all methods and NDVI data\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Environmental exposure layers for San Diego bike routes lines data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncount\narea\nmin\nmax\nrange\nmean\nstd\nsum\n\n\n\n\nPO_bike\n277\n693047.3\n1.0000000\n84.0000000\n83.0000000\n7.2815884\n9.4647429\n2017.0000000\n\n\nKDE_bike\n2924\n7315749.8\n0.0000000\n0.0139834\n0.0139834\n0.0002593\n0.0008235\n0.7581425\n\n\nDR_bike\n1391\n3480242.4\n0.0299472\n9.0428655\n9.0129184\n1.2824664\n1.3475486\n1783.9107457\n\n\nLS_bike\n9803\n24526747.7\n0.1850707\n29764.5585938\n29764.3735231\n299.7464519\n2131.9429532\n2938414.4679463\n\n\n\n\n\n\nTable 8: Table of statistics for all methods and San Diego bike routes lines data"
  },
  {
    "objectID": "report2.html#raster-statistics",
    "href": "report2.html#raster-statistics",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "5 Raster statistics",
    "text": "5 Raster statistics\nFunction rast_stats() calculates raster statistics utilizing terra::global(), terra::freq() and terra::expanse() functions. Statistics for any number of rasters are apposed in data frame.\n\n\n\nListing 10: rast_stats function\n\n\n\n\nCode\n# Statistics calculation function\n\nrast_stats =  function(..., stats, row_names = NULL){\n\n  elipsis_list = list(...)\n  el_class = sapply(elipsis_list, class)\n  if (!all(el_class == \"SpatRaster\")){\n    if (any(el_class == \"SpatRaster\")){\n      warning(\"Skipping not SpatRaster class arguments\")\n      elipsis_list = elipsis_list[el_class == \"SpatRaster\"]\n    } else {\n      stop(\"None of arguments is SpatRaster class\")\n    }\n  }\n\n  if (any(sapply(elipsis_list, function(x) {terra::crs(x)}) == \"\")  && \"area\" %in% stats) { # when\n    warning(\"Empty crs of one of arguments - area statistic will not be calculated\")\n    stats = stats[!stats == \"area\"]\n  }\n  if (missing(stats) || length(stats) == 0){\n    stop(\"No statistic to be calculated\")\n  }\n\n  df = data.frame(matrix(ncol = length(stats)))[-1,]\n  for (raster in elipsis_list){\n\n    row_df = data.frame(matrix(NA, ncol=1, nrow=1))[-1]\n    for (statistic in stats){\n\n      column = switch(\n        statistic,\n        range = {range = terra::global(raster, fun = \"range\", na.rm = TRUE)\n        val = range[2] - range[1]\n        colnames(val) = \"range\"\n        val},\n        count = {raster |&gt; terra::freq() |&gt; dplyr::summarise(count = sum(count))},\n        area = {raster |&gt; terra::expanse() |&gt; dplyr::select(area)},\n        terra::global(raster, fun = statistic, na.rm = TRUE)\n      )\n      row_df = cbind(row_df, column)\n    }\n    df = rbind(df, row_df)\n  }\n\n  if (is.null(row_names)){\n    el_names = names(elipsis_list)\n    names_repl = which(el_names == \"\")\n    el_names[names_repl] = names_repl\n    rownames(df) = el_names\n  } else if (length(row_names) == length(elipsis_list)) {\n    rownames(df) = row_names\n  } else {\n    warning(\"Incorrect length of row_names argument - default output row names\")\n  }\n\n  return(df)\n}\n\n\n\n\n\nEntirety of statistics tables are calculated using rast_stats() (Table 2, Table 3, Table 4, Table 8, Table 7)."
  },
  {
    "objectID": "report2.html#package-issues",
    "href": "report2.html#package-issues",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "6 Package issues",
    "text": "6 Package issues\n\n6.1 Extent and output\nSplitting SpatVector GPS data introduces issues regarding SpatRaster extent and output format. Whilst considering extent with multiple SpatRaster, it may be adressed doubly. SpatRasters has various extents or all SpatRasters maintain identical extent. First, various extents are calculated by cropping grid raster to the minimal feasible extent, preserving grid raster cellsize and converting SpatVector data to cropped grid raster. It is solely overwritten by grid extent argument. Output of this approach must be a list of SpatRasters. Additionally, it enables avoiding disproportion between broad extents and data with clustered spatial distribution.\n\n# calculate seperate extents\n\nif (missing(grid_extent)) {\n  #new ext for each group\n  # get extent\n  group_extent = terra::ext(data_i)\n  # new extent - expanded extent by bandwidth\n  new_group_extent = c(terra::xmin(group_extent) - bandwidth,\n                       terra::xmax(group_extent) + bandwidth,\n                       terra::ymin(group_extent) - bandwidth,\n                       terra::ymax(group_extent) + bandwidth)\n\n  # crop ext of each rast\n  grid_crop = terra::crop(grid_rast, new_group_extent)\n  \n  kde_rast = spat_kde(data_i, grid_crop, bandwidth) # method specific calculation\n} else {\n  kde_rast = spat_kde(data_i, grid_rast, bandwidth) # method specific calculation\n}\n\n# add to list\nact_out[length(act_out) + 1] = as.list(kde_rast)\n\nSecondly, identical extent across every SpatRaster is accomplished by rasterizing all SpatVectors to grid raster without cropping. Uniform extents allows implementing alternative output type. Instead of output list of several items, output is generated as singular SpatRaster with multiple layers. Second approach proposes significantly more cohesive output, facilitating usage of data and allowing saving it to a single file.\n\n# calculate same extent\nkde_rast = spat_kde(data_i, grid_rast, bandwidth) # method specific calculation\n\n# add SpatRaster as another layer\nact_out = append(act_out, kde_rast)\n\n# all items iterated\nact_out\n## class       : SpatRaster \n## dimensions  : 1607, 736, 8  (nrow, ncol, nlyr)\n## resolution  : 50, 50  (x, y)\n## extent      : 459538, 496338, 3600575, 3680925  (xmin, xmax, ymin, ymax)\n## coord. ref. : WGS 84 / UTM zone 11N (EPSG:32611) \n## source(s)   : memory\n## names       :         last,         last,         last,         last,         last,         last, ... \n## min values  : 1.081063e-14, 4.887112e-15, 6.871992e-11, 2.675202e-12, 9.057847e-11, 2.405132e-09, ... \n## max values  : 7.885379e-05, 1.000735e-03, 7.455308e-04, 1.523175e-03, 6.601711e-04, 7.408324e-05, ... \n\n\n\n6.2 Line Segment normalization\nDue to different workflow of Line Segment method applying activity raster normalization is problematic and cannot be accomplished solely by rescaling activity raster values. Thus two approaches of Line Segment are derived and implemented in time_only_norm argument.\nFirst method of time normalization uses only time elapsed and utilizes BBmisc::normalize() on column of time data. Following computation of time elapsed, data frame last value (which is NA from diff_time() function) is set to 0 for proper normalization values.\n\n# calculate time elapsed from all points\nduration_line_id = data_proj |&gt;\n      dplyr::mutate(time_elapsed = as.numeric(difftime(dplyr::lead(.data[[time_cname]]), .data[[time_cname]], units = time_unit)),line_id = dplyr::row_number()) |&gt;\n      dplyr::select(line_id, time_elapsed)\n\n\n\n# max time\nmax(duration_line_id$time_elapsed, na.rm = TRUE)\n## [1] 2272.633\n\n# min time\nmin(duration_line_id$time_elapsed, na.rm = TRUE)\n## [1] 0.1666667\n\n# last NA value set to 0 for normalization to not set lowest time value to 0\nduration_line_id$time_elapsed[nrow(duration_line_id)] = 0\n\n# first 50 normalized values\nhead(round(BBmisc::normalize(duration_line_id$time_elapsed, method = \"range\", margin = 1), 5), n =50)\n##  [1] 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007\n## [12] 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007\n## [23] 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007\n## [34] 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007 0.00007\n## [45] 0.00007 0.00007 0.00007 0.00007 0.00010 0.00012\n\nSecond approach of normalization of Line Segment method is rasterization of SpatVector trajectory buffers. Maximal value from SpatRaster is retrieved and implemented in normalizing buffer SpatVector attribute. It enables normalizing Line Segment method without time data. It is only applicable to range normalization method.\n\nduration_df = as.data.frame(duration_line_id)\n\ntrajectories = terra::vect(trajectories_fun(data_proj))\n\n# create buffers over line segments\ntraj_buff = trajectories |&gt;\n  tidyterra::select(line_id) |&gt;\n  terra::buffer(bandwidth)\n\ntraj_buff$act = 1\ntraj_buff = dplyr::left_join(traj_buff, duration_df, by = 'line_id')\ntraj_buff = traj_buff[,-2]\nnames(traj_buff)[2] = \"act\"\n\nnorm_rast = terra::rasterize(traj_buff, grid_rast, field = \"act\", fun = \"sum\")\n#read max val\nmax_norm = terra::minmax(norm_rast)[2]\n\n# normalize\nif (length(unique(traj_buff$act)) == 1){\n  #if vector is constant adjust BBmisc\n  traj_buff$act = BBmisc::normalize(traj_buff$act, method = \"range\",\n                                    margin = 1L, range = c(0, max(traj_buff$act) / max_norm * 2))\n} else{\n  traj_buff$act = BBmisc::normalize(traj_buff$act, method = \"range\",\n                                    margin = 1L, range = c(0, max(traj_buff$act) / max_norm))\n}\n\n# max raster val\nminmax(norm_rast)[2]\n## [1] 7317.602\n\n# min raster val\nminmax(norm_rast)[1]\n## [1] 0.1666667\n\n# first 50 normalized values\nBBmisc::normalize(traj_buff$act, method = \"range\", margin = 1L, range = c(0, max(traj_buff$act) / max_norm)) |&gt; round(9) |&gt; head(n=50)\n##  [1] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000\n##  [8] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000\n## [15] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000\n## [22] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000\n## [29] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000\n## [36] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000\n## [43] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.000000001\n## [50] 0.000000002\n\nLatter normalization’s output resembles PO/KDE/DR normalization more than former approach though maximal value after converting SpatVector to SpatRaster is approximate to 1.\n\n# min norm 1\nminmax(norm_1)[1]\n## [1] 0.00007333636\n\n# max norm 1\nminmax(norm_1)[2]\n## [1] 3.219877\n\n# min norm 2\nminmax(norm_2)[1]\n## [1] 0\n\n# max norm 2\nminmax(norm_2)[2]\n## [1] 0.9964741\n\n\n\n\n\n\n\n\n\nFigure 17: Line Segment method - two types of normalization\n\n\n\n\n\n\n\n6.3 Name\nPackage requires a name more memorable than twsagps. Several new acronyms are proposed:\nTWIGPS - Time-Weighted Integrated GPS (Time-Weighted spatial averaging methods Integrated with GPS) - personal favourite\nHEXOSIS - Human (or Health) Environmental eXposure Over Space and time with Integrated GPS\nHEXGPS - Human (or Health) Environmental eXposure with GPS\nGPSHEAL - GPS-based Health and Environmental Assessment Locator"
  },
  {
    "objectID": "report2.html#further-development",
    "href": "report2.html#further-development",
    "title": "Creating software for environmental measurements based on GPS data - twsagps package report number 2",
    "section": "7 Further development",
    "text": "7 Further development\nThe BBmisc::normalize() and terra::writeRaster() functions possess great amount of not applied arguments that the user may consider utilizing. Incorporating those arguments as elipsis in exposure functions may be beneficial.\nThe spat_kde() and spat_dr() (along with kde() and kde_points()) functions features should be extented. Establishing those functions as standalone package function will enlarge and enrich twsagps application range.\nFurther work on twsagps package should focus on developing and enhancing documentation and error handling system."
  },
  {
    "objectID": "quarto_test/test.html",
    "href": "quarto_test/test.html",
    "title": "",
    "section": "",
    "text": "title: “test”\n\n\nformat: html\n\n\neditor: visual"
  },
  {
    "objectID": "quarto_test/test.html#quarto",
    "href": "quarto_test/test.html#quarto",
    "title": "",
    "section": "Quarto",
    "text": "Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org.\n\nlibrary(terra)\n\nterra 1.7.65\n\nlibrary(sf)\n\nLinking to GEOS 3.11.2, GDAL 3.7.2, PROJ 9.3.0; sf_use_s2() is TRUE\n\nlibrary(tmap) \n\nBreaking News: tmap 3.x is retiring. Please test v4, e.g. with\nremotes::install_github('r-tmap/tmap')\n\nlibrary(dplyr)\n\n\nDołączanie pakietu: 'dplyr'\n\n\nNastępujące obiekty zostały zakryte z 'package:terra':\n\n    intersect, union\n\n\nNastępujące obiekty zostały zakryte z 'package:stats':\n\n    filter, lag\n\n\nNastępujące obiekty zostały zakryte z 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tmaptools)\nlibrary(twsagps)\nlibrary(rbenchmark)"
  },
  {
    "objectID": "quarto_test/test.html#running-code",
    "href": "quarto_test/test.html#running-code",
    "title": "",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n#example ref grid and points\nexp_point = geolife_sandiego |&gt; filter(dateTime %in% c(\"2011-08-18 02:27:11\", \"2011-08-19 04:24:54\", \"2011-08-21 03:57:00\", \"2011-08-18 03:16:43\", \"2011-08-18 01:26:31\", \"2011-08-21 04:24:11\", \"2011-08-21 03:03:14\")) |&gt; vect(geom = c(\"lon\", \"lat\"), crs = \"EPSG:4326\")\n\n\nknitr::kable(terra::crds(exp_point), \"html\", caption = \"Points coords\", full_width = FALSE, align = \"c\")\n\n\n\nPoints coords\n\n\nx\ny\n\n\n\n\n-117.1618\n32.71498\n\n\n-117.1620\n32.71450\n\n\n-117.1605\n32.71633\n\n\n-117.1602\n32.71455\n\n\n-117.1616\n32.71436\n\n\n-117.1626\n32.71445\n\n\n-117.1613\n32.71496\n\n\n\n\n\n\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  }
]